# Design Decision: Firewall Rule Caching

## Problem
The firewall middleware fetches rules from the database for every incoming request. This is highly inefficient, as it results in a database query for each static asset (CSS, JS, images) and every API call to a proxied application. This will cause a significant performance bottleneck under load.

## Solution: In-Memory Cache with Invalidation-on-Write
To optimize performance, we will implement an in-memory cache for firewall rules.

### How it Works:
1.  **Cache Storage**: A global, thread-safe, in-memory map will be used to store rules, with the `projectID` as the key and the list of rules (`[]storage.Rule`) as the value.
2.  **Firewall Middleware Logic**:
    *   On an incoming request, the middleware will first check the cache for the project's rules.
    *   **Cache Hit**: If rules are found, they are used immediately. No database query is performed.
    *   **Cache Miss**: If rules are not found, they are fetched from the database and then stored in the cache for subsequent requests.
3.  **Cache Invalidation**:
    *   When a rule is created, updated, or deleted via the management API, the handler for that operation will be responsible for clearing the cache for that specific `projectID`.
    *   This "invalidation-on-write" strategy ensures that any change to the rules will be immediately reflected, as the next request to the firewall for that project will trigger a cache miss and force a database fetch.

This approach provides high performance for the vast majority of requests while ensuring data consistency when rules are modified.

---

# Design Decision: Path-Based Dynamic Routing

This document captures the critical insight regarding how the firewall will handle requests for multiple, distinct projects and users.

## The Core Problem

Instead of proxying to a single address, the firewall must handle three distinct types of requests based on the URL's path:

1.  **Project Traffic**: Requests for a specific project (e.g., `/<project_name>`).
2.  **Admin Traffic**: Requests by a user to access their management dashboard (e.g., `/<user_name>`).
3.  **API Traffic**: Internal API calls for configuration (e.g., `/api/...`).

## The Architectural Solution: Path-Based Routing

The application, named "Prism", will use a central router (multiplexer) to direct traffic based on the request's URL path.

### How it Works:

1.  **Request Arrives**: A request hits the main application endpoint (e.g., `http://prism.local/`).

2.  **Router Inspection**: A router at the entry point inspects the URL path.

3.  **Routing Logic**:
    *   If the path matches a known project name (e.g., `/project-alpha`), the router sends the request to the **Reverse Proxy Module**. The proxy then looks up that project's backend URL in the database and forwards the request.
    *   If the path starts with `/user/` (e.g., `/user/Karan`), the router sends the request to the **Admin Dashboard Handler**. This handler will be responsible for serving the user-specific management UI.
    *   If the path starts with `/api/`, the router sends the request to the **Management API Handler**. This API is protected by Clerk authentication.

## Implications

- **Centralized Logic**: A main router becomes the single point of entry, simplifying the request flow.
- **Clear Separation**: The three main functions (proxying, admin UI, and API) are cleanly separated and handled by different internal modules.
- **Database is Key**: The database must store mappings for project paths to upstream URLs, and user paths to their respective accounts.